DataCon 2025软件供应链安全赛道- 密钥猎人
1) 题目背景
随着开源协作与持续集成流程的广泛应用，密钥泄露事件愈发频繁，已成为威胁企业和开发者安全的重要隐患。各类文本文件（如源代码、配置文件、日志等）中常常埋藏着 API Token、访问密钥等敏感凭证。参赛选手需分析主办方提供的数据集，开发自动化检测工具，尽可能发现潜在密钥并有效减少误报。

2) 题目要求
参赛者需开发自动化密钥检测工具，对主办方提供的数据集进行分析并提取潜在密钥（静态分析，不涉及真实验证有效性）。

数据集中包含各类代码项目的明文源文件，部分文件含有密钥；为增加挑战性，数据还额外加入了若干构造密钥。
最终成绩将综合 工具检测得分、效率得分 以及 答辩得分 综合进行排名。

3) 数据说明
数据集结构：文件类型包含文本文件如代码、数据、配置、日志等。数据集中每个文件以样本内容的md5值命名，没有后缀。
唯一密钥：以“文件名+ 密钥值”为单位进行唯一判定。
⚠️ 注意：若同一文件多次提交相同密钥，仅 首次密钥计分。
4)附件下载

MD5: 6528c5ccec73ede051b4c3781236d700  dataconfiles.tar.gz

点击下载

Tips: 构造密钥示例
部分密钥可能经过拼接、混淆或截断，难以通过简单正则匹配捕获，例如：

# Case 1: 
def connect(url, auth):
    print(f"Connecting to {url} with auth token: {auth}")​
    
a = "sk-hm*******iob"
b = "xbhczx"
c = "bd*******bHwb"
secret = a + b + c  
connect("service.example.com", secret)
case2:def api_call(endpoint, header):
    ......
    print(f"Calling {endpoint} with header {header}")​
    
api_call("https://api.example.com/data", "sec*******ret")
case3:
function dtcon_game_login() {
    return requests.post("https://api.game.dtcon.com/biz/user/login", {
      data: "secret_key=gna#3*******d&gdF4QaO&imei=000000000000000&version=2.1.54&_time=1614765847&heybox_id=15249824",        
      headers: {            
          "User-Agent": "dtcon-GameCenter/2.1.43 (Android 12)",            
          "Content-Type": "application/x-www-form-urlencoded",            
          "X-dtcon-Device-Id": imei        
              }   
          }).json();
  }
***:截断

选手可以通过分析校验结果，判断哪些密钥可能获得额外加分。

4) 答案提交方式
 需提交文件 result.json，其内容为一个 JSON 格式列表，每个元素为一个字典，包含：

[
    {        
        "file_hash": "file hash", # 文件名的哈希        
        "value": "your secret" # 检测到的密钥    
    },    
    # ...
]
 正确性判断

短密钥（长度 < 100字符）采用完全相等匹配。
长密钥（长度 ≥ 100字符，如私钥）采用相似度匹配，匹配标准为：Jaro-Winkler 相似度 ≥ 0.8，或SequenceMatcher 相似度 ≥ 0.8。计分规则（F1 Score）
构造密钥具有更高的权重分值（权重为n，如果该密钥正确，相当于命中了n次普通的密钥的次数）：precision = 正确提交数 / 提交密钥总数 recall = 正确提交数 / benchmark总数F1 = 2 × (precision × recall) / (precision + recall)
F1 值 × 100 作为基础得分（满分 100）。

⚠️所有结果均以 file+value 进行归一化计算。

速度奖励分
•在 最终 F1 得分排名前 10 的选手 中进行耗时评估（若 F1 分数差距过小，入围范围可适当扩大）。
•前 10 名耗时最短的选手将获得奖励分，奖励根据实际耗时相对差距分配。

参赛选手需提交 完整、可复现的自动化工具，并在 指定服务器环境 中完成配置和运行，确保输出结果符合要求。提交程序将由主办方在服务器上进行 监督、自动化运行及二次校验，以保证工具的可复现性和结果的有效性。

奖励分计算公式
•T_min：前 10 名中的最小耗时（最快者）
•T_max：前 10 名中的最大耗时（最慢者）
•T_i ：第 (i) 位选手的耗时
•R ：最大奖励分（例如 20 分）
•R_min：最小奖励分（保底，例如 2 分）
计算步骤：

1.归一化耗时：

计算选手 i 的归一化耗时r_i，公式为：r_i=(T_i - T_min) / (T_max - T_min) 
•归一化耗时的值介于 0 到 1 之间，越接近 0 表示越快。2.奖励分计算：
用归一化耗时计算奖励分，公式为：奖励分_i = (1 - r_i) × (R - R_min) + R_min 
这样，最快选手可以获得满分 R，最慢选手获得保底分 R_min，其他选手根据耗时线性分配奖励分。

💡 举例
假设：
•T_min = 10 秒/文件
•T_max = 110 秒/文件
•R = 20 分
•R_min = 2 分

名次	耗时（秒/文件）	奖励分说明	奖励分
1	10	归一化耗时 0，奖励分为 18+2分	20
2	30	归一化耗时约为0.2，奖励分约为 14.4+2 分	16.4
10	110	归一化耗时 1，奖励分为保底 2 分	2

-----------------------------------------------------------------------
本地开发信息:
rustc 1.91.0 (f8297e351 2025-10-28)
cargo 1.91.0 (ea2d97820 2025-10-10)

所有的目标文件(解压后)我放在:
/home/sinon/study/datacon/all_files_hash 目录下,其中包含 120W个文件(单层级文件均在此一个目录下),内容绝大部分为文本段或代码段,少部分为2进制文件

我从中提取了 2500 个样本放在了下面目录,做开发调试用 
/home/sinon/study/datacon/keyhunter/exmple

为了保证速度和性能,我们决定采用 rust 语言编写工具。
开发过程中先不强行追求性能,先以准确率为优,项目后期再进行性能调休。

开发过程中,每个关键功能位置需要添加好标准的注释说明,代码注释请使用中文。